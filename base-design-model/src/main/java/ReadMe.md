# 设计模式-该模块中的utils是设计模式工具包

## 一、观察者模式-一对多

**简介：发布订阅模式**

1. 定义一个消息类
2. 定义一个观察者接口
3. 定义一个观察类，拥有一个接收指定消息的接口
4. 定义一个发布者接口，
5. 定义一个发布者类，实现新增删除和通知观察责这几个方法

## 二、装饰者模式-运用组合在不修改源代码的情况下扩展功能 新的行为和责任

**简介：动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。**

1. 定义一个抽象类，有成本和描述
2. 定义多个组件，继承该抽象类，实现自己的价格和描述
3. 定义一个装饰抽象类，其描述方法也是抽象的
4. 定义多个装饰类

## 三、工厂模式-不想自己实例化对象，用工厂方法

**简介：工厂处理对象创建的细节，依赖倒置原则-高层依赖于低层**

设计原则：变量不持有具体类的引用、不让类派生自具体类、不覆盖基类中已有的方法

#### 一、简单工厂-创建一个产品

1. 定义一个仓库者，创建过程交给工厂类来完成（其只负责创建对象）。然后对该产品进行固定操作

#### 二、工厂方法-创建一个产品具体实现不同-继承

简介：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

#### 三、抽象工厂-创建一组产品-组合

简介：使用抽象接口来创建一组相关的产品，而不需要知道实际产出的具体产品是说明。

1. 在产品中组合工厂，通过工厂获取需要的组件信息。

## 四、单件模式-永远只有一个对象

1. 饿汉式-每次来就创建-避免线程安全的问题
2. 懒汉式-有就不创建-需要解决线程安全的问题
3. 线程安全
    1. 方法添加关键字synchronized
    2. 双重加锁

## 五、命令模式-封装方法调用-使动作的请求者和动作的执行者解耦

简介：将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

1. 定义一个命令接口，支持执行和撤销
2. 定义多个执行者，负责执行不同的操作
3. 定义多个命令类，里面放入不同的执行者，当操作执行时调用不同的方法
4. 撤销操作：记录上一个命令，当撤销时直接调用上一个，有些情况下可以直接在命令层进行处理
5. 宏操作：定义一个命令类，接收为命令数组，撤销和执行都通过遍历数组来执行

## 六、适配器模式（接口适配）与外观模式（同一外观，不同具体实现）

##### 适配器模式-一个适配器类只适配一个接口-可以实现双向适配器

1. 对象适配器：定义一个适配器类，实现适配接口，同时将实例变量设置为需要被适配的类
2. 类适配器：适配器类继承了目标类和被适配的类

##### 外观模式-一个适配器包装多个被适配类 让接口更加简单

简介：外观模式提供了一个统一的接口。用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

1. 最少知识原则-方针
   1. 该对象本身
   2. 被当作方法参数传入的对象
   3. 此方法锁创建或实例化的任何对象
   4. 对象的任何组件

## 七、模板方法模式- 相同方法不同实现抽离

简介：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

1. 定义一个抽象类，调用由抽象类完成，实现交给子类
2. 钩子：可以让子类有能力对算法的不同点进行挂载，要不要挂载由子类决定。

好莱坞原则，高层依赖低层，低层不依赖高层

## 八、迭代器与组合模式-管理良好的集合

迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 **集合访问**

组合模式：允许你将对象组合成属性结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象集合。**树形结构**

1. 定义顶层迭代接口
2. 需要迭代的类都实现该接口
3. 直接使用

## 九、状态模式

简介：状态模式允许对象在内部状态改变时改变他的行为，对象看起来好像修改了他的类

状态模式和策略模式的区别：状态模式通过上下文进行状态的改变和操纵，但是策略模式是直接通过上下文选择具体的策略

1. 定义顶层状态接口
2. 实现多个状态接口，每个状态中都有一个上下文对象
3. 定义环境接口，组合多个状态和当前状态，执行时永远执行的都是当前的状态

## 十、代理模式-控制某个对象的操作

简介：为另一个对象提供要给替身或占位符以控制对这个对象的访问

1. 静态代理（运行前九创建好了）
2. 动态代理（运行时创建对象）jdk和cglib

## 十一、复合模式-多个模式解决方案

简介：整合各种设计模式解决问题

需求清单:

1. 所有鸭子都会叫，并且不同鸭子的叫声不同（多态）
2. 当鸭子叫的时候，鹅也会跟着一起叫（适配器）
3. 统计所有叫声的数量 （装饰者）
4. 有许多鸭子没被装饰的鸭子叫声没被计算进去 （工厂）
5. 监管员想个别管理一群鸭子 （复合模式）
6. 追踪个别鸭子实时的呱呱叫 （监听者模式）

#### 复合模式之王-MVC

1. 模型-数据
2. 视图-样式
3. 控制器-使数据和样式交互
4. 使用的模式
   1. 观察者 控制器观察视图
   2. 策略 视图切换控制器
   3. 组合模式
   4. 适配模式

## 十二、与设计模式相处

简介：模式是在某情境下，针对某问题的某种解决方法

1. 创建型-对象怎么创建
2. 结构型-对象怎么组织
3. 行为型-对象行为怎么委托、分配

#### 思考模式

1. 保持简单（简单且富有弹性）
2. 设计模式并非长生药
3. 何时需要模式-可以解决问题
4. 拿掉不需要的
5. 如果不需要就别做

## 十三、剩下的模式（采用不多，需要时可以直接使用）

1. **桥接-改变实现和抽象**
   1. 跨平台
   2. 用不同的方式改变接口和实现
   3. 增加了复杂度
2. **建造者-封装了一个产品的构造过程，并允许按步骤构造**
   1. 用来创建组合结构
   2. 客户需要具备更多的领域知识
   3. 将一个复杂对象的创建过程封装起来
   4. 允许对象通过多个步骤来吵架呢，并且可以改变过程
   5. 向客户隐藏产品内部的表现
   6. 产品的实现可以被替换，因为客户只看到一个抽象的接口
3. **责任链-一个以上的对象有机会能够处理某个请求的时候**
   1. 粉丝信息送给CEO
   2. 抱怨信息送给法律部门
   3. 新机器请求送给业务
   4. 垃圾邮件删除
   5. **优缺点**
      1. 将请求发送者和接收者解耦
      1. 简化对象
      1. 动态地新增或者删除责任
      1. 经常被用在窗口系统中
      1. 并不保证请求一定会执行
      1. 不易观察运行时的特征，有碍于除错
4. 蜗量-一个实例用来提供许多虚拟
   1. 节省内存
   2. 集中管理
   3. 需要集中管理时使用
   4. 无法拥有独立而不同的行为
5. 解释器-为语言创建解释器
   1. 将每一个语法规则表示成一个类，方便实现语言
   2. 轻易的改变和扩展语言
   3. 在解释的同时增加新的行为
   4. 需要实现一个简单的语言时，使用解释器
   5. 有一个简单的语法，简单比效率更重要时，使用解释器
   6. 处理脚本语言和编程语言
   7. 规则多时，模式会变得繁杂，使用解析器/编译器的产生器可能会更好
6. **中介者-集中相关对象之间复杂的沟通和控制方式**
   1. 通过将对象彼此解耦，增加对象的复用性
   2. 将控制逻辑集中，简化系统维护
   3. 让对象之间锁传递的消息变得简单而答复减少
   4. 常常被用来协调相关的GUI组件
   5. 如果设计不当，本身会变的过于复杂
7. 备忘录-让对象返回之前的状态时
   1. 将被储存的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。
   2. 保持关键对象的数据封装
   3. 提供了容易实现的恢复能力
   4. 备忘录用于存储状态
   5. 存储和恢复的过程可能相当耗时
   6. 推荐使用序列化方式存储状态
8. 原型-给定类的实例过程很昂贵复杂时，使用原型模式
   1. 隐藏复杂性
   2. 复制可能比创建更有效
   3. 复制有时可能相当复杂
9. **访问者-为一个对象的组合增加新的功能，且封装并不重要时，就使用访问者模式**
   1. 允许你对组合结构加入新的操作，而无需改变结构本身
   2. 想要加入新的操作，相对容易
   3. 访问者进行的操作，代码是集中在一起的
   4. 采用访问者模式的时候，就会打破组合类的封装
   5. 因为游走的功能牵涉其中，所以对组合结构的改变就更加困难